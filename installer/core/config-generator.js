const fs = require('fs').promises;
const path = require('path');

class ConfigGenerator {
  constructor() {
    this.templatesDir = path.join(__dirname, '../../config-templates');
  }

  /**
   * データベース設定ファイル（database.properties）を生成
   * @param {Object} config - 設定オブジェクト
   * @returns {string} 生成された設定ファイルの内容
   */
  generateDatabaseProperties(config) {
    const { database, transaction, sql, metrics, crossPartitionScan } = config;
    
    let properties = [];
    
    // Transaction Manager
    properties.push(`# ScalarDB Configuration`);
    properties.push(`# Generated by ScalarDB Installer`);
    properties.push('');
    properties.push(`scalar.db.transaction_manager=${transaction?.manager || 'consensus-commit'}`);
    properties.push('');
    
    // Database specific configuration
    switch (database.type) {
      case 'postgresql':
        properties.push('# PostgreSQL Configuration');
        properties.push('scalar.db.storage=jdbc');
        properties.push(`scalar.db.contact_points=jdbc:postgresql://${database.host}:${database.port}/${database.database}`);
        properties.push(`scalar.db.username=${database.username}`);
        properties.push(`scalar.db.password=${database.password}`);
        break;
        
      case 'mysql':
        properties.push('# MySQL Configuration');
        properties.push('scalar.db.storage=jdbc');
        properties.push(`scalar.db.contact_points=jdbc:mysql://${database.host}:${database.port}/${database.database}`);
        properties.push(`scalar.db.username=${database.username}`);
        properties.push(`scalar.db.password=${database.password}`);
        break;
        
      case 'cassandra':
        properties.push('# Cassandra Configuration');
        properties.push('scalar.db.storage=cassandra');
        properties.push(`scalar.db.contact_points=${Array.isArray(database.hosts) ? database.hosts.join(',') : database.hosts}`);
        properties.push(`scalar.db.contact_port=${database.port}`);
        properties.push(`scalar.db.username=${database.username}`);
        properties.push(`scalar.db.password=${database.password}`);
        break;
        
      case 'dynamodb':
        properties.push('# DynamoDB Configuration');
        properties.push('scalar.db.storage=dynamo');
        properties.push(`scalar.db.contact_points=${database.region}`);
        properties.push(`scalar.db.username=${database.accessKey}`);
        properties.push(`scalar.db.password=${database.secretKey}`);
        if (database.endpointOverride) {
          properties.push(`scalar.db.dynamo.endpoint_override=${database.endpointOverride}`);
        }
        break;
        
      case 'cosmos':
        properties.push('# Azure Cosmos DB Configuration');
        properties.push('scalar.db.storage=cosmos');
        properties.push(`scalar.db.contact_points=${database.endpoint}`);
        properties.push(`scalar.db.username=${database.key}`);
        properties.push(`scalar.db.password=${database.key}`);
        break;
    }
    
    properties.push('');
    
    // Consensus Commit Configuration
    if (transaction) {
      properties.push('# Consensus Commit Configuration');
      if (transaction.isolationLevel) {
        properties.push(`scalar.db.consensus_commit.isolation_level=${transaction.isolationLevel}`);
      }
      if (transaction.serializableStrategy) {
        properties.push(`scalar.db.consensus_commit.serializable_strategy=${transaction.serializableStrategy}`);
      }
      properties.push('');
    }
    
    // SQL Configuration
    if (sql && sql.enabled) {
      properties.push('# SQL Configuration');
      properties.push(`scalar.db.sql.enabled=${sql.enabled}`);
      properties.push(`scalar.db.sql.server.port=${sql.port || 60052}`);
      properties.push('');
    }
    
    // Cross Partition Scan Configuration
    if (crossPartitionScan) {
      properties.push('# Cross Partition Scan Configuration');
      properties.push(`scalar.db.cross_partition_scan.enabled=${crossPartitionScan.enabled}`);
      properties.push('');
    }
    
    // Metrics Configuration
    if (metrics && metrics.enabled) {
      properties.push('# Metrics Configuration');
      properties.push(`scalar.db.metrics.enabled=${metrics.enabled}`);
      properties.push(`scalar.db.metrics.port=${metrics.port || 8080}`);
      properties.push('');
    }
    
    return properties.join('\n');
  }

  /**
   * スキーマファイル（schema.json）を生成
   * @param {Object} tableConfig - テーブル設定
   * @returns {string} 生成されたスキーマファイルの内容
   */
  generateSchema(tableConfig) {
    const {
      tableName,
      transactionEnabled,
      partitionKeys,
      clusteringKeys,
      columns,
      secondaryIndexes,
      compactionStrategy = 'LCS'
    } = tableConfig;
    
    const schema = {
      [tableName]: {
        transaction: transactionEnabled,
        'partition-key': partitionKeys,
        columns: {}
      }
    };
    
    // Clustering keys (optional)
    if (clusteringKeys && clusteringKeys.length > 0) {
      schema[tableName]['clustering-key'] = clusteringKeys;
    }
    
    // Columns
    columns.forEach(column => {
      schema[tableName].columns[column.name] = column.type;
    });
    
    // Secondary indexes (optional)
    if (secondaryIndexes && secondaryIndexes.length > 0) {
      schema[tableName]['secondary-index'] = secondaryIndexes;
    }
    
    // Compaction strategy
    schema[tableName]['compaction-strategy'] = compactionStrategy;
    
    return JSON.stringify(schema, null, 2);
  }

  /**
   * Docker Composeファイルを生成
   * @param {Object} config - 設定オブジェクト
   * @returns {string} 生成されたDocker Composeファイルの内容
   */
  generateDockerCompose(config) {
    const { database, scalardb, monitoring } = config;
    
    let compose = {
      version: '3.8',
      services: {},
      volumes: {},
      networks: {
        default: {
          name: 'scalardb-network'
        }
      }
    };
    
    // Database services
    switch (database.type) {
      case 'postgresql':
        compose.services.postgres = {
          image: 'postgres:15',
          container_name: 'scalardb-postgres',
          environment: {
            POSTGRES_DB: database.database,
            POSTGRES_USER: database.username,
            POSTGRES_PASSWORD: database.password
          },
          ports: [`${database.port}:5432`],
          volumes: ['postgres_data:/var/lib/postgresql/data'],
          restart: 'unless-stopped'
        };
        compose.volumes.postgres_data = {};
        break;
        
      case 'mysql':
        compose.services.mysql = {
          image: 'mysql:8.0',
          container_name: 'scalardb-mysql',
          environment: {
            MYSQL_DATABASE: database.database,
            MYSQL_USER: database.username,
            MYSQL_PASSWORD: database.password,
            MYSQL_ROOT_PASSWORD: database.rootPassword || 'rootpass'
          },
          ports: [`${database.port}:3306`],
          volumes: ['mysql_data:/var/lib/mysql'],
          restart: 'unless-stopped'
        };
        compose.volumes.mysql_data = {};
        break;
        
      case 'cassandra':
        compose.services.cassandra = {
          image: 'cassandra:4.0',
          container_name: 'scalardb-cassandra',
          environment: {
            CASSANDRA_CLUSTER_NAME: 'ScalarDB Cluster',
            CASSANDRA_DC: 'datacenter1',
            CASSANDRA_RACK: 'rack1'
          },
          ports: [`${database.port}:9042`, '7000:7000'],
          volumes: ['cassandra_data:/var/lib/cassandra'],
          restart: 'unless-stopped'
        };
        compose.volumes.cassandra_data = {};
        break;
        
      case 'dynamodb':
        if (database.local) {
          compose.services['dynamodb-local'] = {
            image: 'amazon/dynamodb-local',
            container_name: 'scalardb-dynamodb',
            ports: [`${database.port || 8000}:8000`],
            command: '-jar DynamoDBLocal.jar -sharedDb -optimizeDbBeforeStartup',
            volumes: ['dynamodb_data:/home/dynamodblocal/data'],
            restart: 'unless-stopped'
          };
          compose.volumes.dynamodb_data = {};
        }
        break;
    }
    
    // ScalarDB Server
    if (scalardb && scalardb.server) {
      const dependsOn = [];
      if (database.type === 'postgresql') dependsOn.push('postgres');
      if (database.type === 'mysql') dependsOn.push('mysql');
      if (database.type === 'cassandra') dependsOn.push('cassandra');
      if (database.type === 'dynamodb' && database.local) dependsOn.push('dynamodb-local');
      
      compose.services['scalardb-server'] = {
        image: `ghcr.io/scalar-labs/scalardb-server:${scalardb.version}`,
        container_name: 'scalardb-server',
        ports: [
          `${scalardb.serverPort || 60051}:60051`,
          `${scalardb.metricsPort || 8080}:8080`
        ],
        volumes: [
          './database.properties:/scalardb/database.properties'
        ],
        environment: {
          SCALAR_DB_CONFIG_FILE: '/scalardb/database.properties'
        },
        restart: 'unless-stopped'
      };
      
      if (dependsOn.length > 0) {
        compose.services['scalardb-server'].depends_on = dependsOn;
      }
      
      if (scalardb.schemaFile) {
        compose.services['scalardb-server'].volumes.push(
          `./${scalardb.schemaFile}:/scalardb/schema.json`
        );
      }
    }
    
    // Monitoring services
    if (monitoring && monitoring.enabled) {
      compose.services.prometheus = {
        image: 'prom/prometheus:latest',
        container_name: 'scalardb-prometheus',
        ports: ['9090:9090'],
        volumes: [
          './prometheus.yml:/etc/prometheus/prometheus.yml',
          'prometheus_data:/prometheus'
        ],
        command: [
          '--config.file=/etc/prometheus/prometheus.yml',
          '--storage.tsdb.path=/prometheus',
          '--web.console.libraries=/etc/prometheus/console_libraries',
          '--web.console.templates=/etc/prometheus/consoles'
        ],
        restart: 'unless-stopped'
      };
      
      compose.services.grafana = {
        image: 'grafana/grafana:latest',
        container_name: 'scalardb-grafana',
        ports: ['3000:3000'],
        environment: {
          GF_SECURITY_ADMIN_PASSWORD: monitoring.grafanaPassword || 'admin'
        },
        volumes: ['grafana_data:/var/lib/grafana'],
        restart: 'unless-stopped'
      };
      
      compose.volumes.prometheus_data = {};
      compose.volumes.grafana_data = {};
    }
    
    return this._yamlStringify(compose);
  }

  /**
   * 設定を検証
   * @param {Object} config - 設定オブジェクト
   * @returns {Object} { valid: boolean, errors: string[] }
   */
  validateConfiguration(config) {
    const errors = [];
    
    if (!config.database) {
      errors.push('Database configuration is required');
      return { valid: false, errors };
    }
    
    const { database } = config;
    
    // Database type validation
    const supportedTypes = ['postgresql', 'mysql', 'cassandra', 'dynamodb', 'cosmos'];
    if (!supportedTypes.includes(database.type)) {
      errors.push(`Unsupported database type: ${database.type}`);
    }
    
    // Common required fields
    if (!database.host && database.type !== 'dynamodb') {
      errors.push('Database host is required');
    }
    
    if (!database.port) {
      errors.push('Database port is required');
    } else if (isNaN(database.port)) {
      errors.push('Database port must be a valid number');
    }
    
    if (!database.username) {
      errors.push('Database username is required');
    }
    
    if (!database.password) {
      errors.push('Database password is required');
    }
    
    if (!database.database && ['postgresql', 'mysql'].includes(database.type)) {
      errors.push('Database name is required');
    }
    
    // Type-specific validation
    switch (database.type) {
      case 'cassandra':
        if (!database.hosts && !database.host) {
          errors.push('Cassandra hosts are required');
        }
        break;
        
      case 'dynamodb':
        if (!database.region && !database.endpointOverride) {
          errors.push('DynamoDB region or endpoint override is required');
        }
        if (!database.accessKey) {
          errors.push('DynamoDB access key is required');
        }
        if (!database.secretKey) {
          errors.push('DynamoDB secret key is required');
        }
        break;
        
      case 'cosmos':
        if (!database.endpoint) {
          errors.push('Cosmos DB endpoint is required');
        }
        if (!database.key) {
          errors.push('Cosmos DB key is required');
        }
        break;
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * 設定ファイルを保存
   * @param {Object} config - 設定またはテーブル設定
   * @param {string} type - 'database-properties' | 'schema' | 'docker-compose'
   * @param {string} outputPath - 出力パス
   * @returns {Object} { success: boolean, filePath: string, error?: string }
   */
  async saveConfiguration(config, type, outputPath) {
    try {
      let content;
      
      switch (type) {
        case 'database-properties':
          content = this.generateDatabaseProperties(config);
          break;
        case 'schema':
          content = this.generateSchema(config);
          break;
        case 'docker-compose':
          content = this.generateDockerCompose(config);
          break;
        default:
          throw new Error(`Unknown configuration type: ${type}`);
      }
      
      await fs.writeFile(outputPath, content, 'utf8');
      
      return {
        success: true,
        filePath: outputPath
      };
    } catch (error) {
      return {
        success: false,
        filePath: outputPath,
        error: error.message
      };
    }
  }

  /**
   * 既存の設定ファイルを読み込み
   * @param {string} filePath - ファイルパス
   * @param {string} type - 設定ファイルの種類
   * @returns {Object} パースされた設定
   */
  async loadConfiguration(filePath, type) {
    try {
      const content = await fs.readFile(filePath, 'utf8');
      
      switch (type) {
        case 'database-properties':
          return this._parseProperties(content);
        case 'schema':
          return JSON.parse(content);
        case 'docker-compose':
          return this._parseYaml(content);
        default:
          throw new Error(`Unknown configuration type: ${type}`);
      }
    } catch (error) {
      throw new Error(`Failed to load configuration: ${error.message}`);
    }
  }

  // Private methods
  
  _parseProperties(content) {
    const config = {};
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, value] = trimmed.split('=', 2);
        if (key && value) {
          config[key.trim()] = value.trim();
        }
      }
    }
    
    return config;
  }
  
  _yamlStringify(obj, indent = 0) {
    const spaces = '  '.repeat(indent);
    let result = '';
    
    for (const [key, value] of Object.entries(obj)) {
      if (value === null || value === undefined) {
        result += `${spaces}${key}:\n`;
      } else if (Array.isArray(value)) {
        result += `${spaces}${key}:\n`;
        for (const item of value) {
          if (typeof item === 'object') {
            result += `${spaces}  - ${this._yamlStringify(item, indent + 2).trim()}\n`;
          } else {
            result += `${spaces}  - ${item}\n`;
          }
        }
      } else if (typeof value === 'object') {
        result += `${spaces}${key}:\n`;
        result += this._yamlStringify(value, indent + 1);
      } else {
        result += `${spaces}${key}: ${value}\n`;
      }
    }
    
    return result;
  }
  
  _parseYaml(content) {
    // Simple YAML parser for basic structures
    // In production, use a proper YAML library like js-yaml
    try {
      return JSON.parse(content);
    } catch {
      throw new Error('YAML parsing not fully implemented - use js-yaml library');
    }
  }
}

module.exports = { ConfigGenerator };